package shuati_2203;

public class 数组异或2 {
    /**
     * 对于题目中说除了两个单个数字外，其他的都出现偶数次。我们需要从这句话入手，寻求更优的解决思路。
     * <p>
     * 我们知道，位运算中异或的性质是：两个相同数字异或=0，不相同的话肯定不为0，一个数和0异或还是它本身。
     * <p>
     * 这个题目的突破口在哪里？题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：
     * 任何一个数字异或它自己都等于0 。也就是说，如果我们从头到尾依次异或数组中的每一个数字，
     * 那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了(异或运算的交换律,可以参考博客:
     * https://blog.csdn.net/luzhensmart/article/details/107586619)。
     * <p>
     * 有了上面简单问题的解决方案之后，我们回到原始的问题。如果能够把原数组分为两个子数组。
     * 在每个子数组中，包含一个只出现一次的数字，而其它数字都出现两次。如果能够这样拆分原数组，
     * 按照前面的办法就是分别求出这两个只出现一次的数字了。
     * <p>
     * 我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。
     * 因为其它数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0 ，
     * 也就是说在这个结果数字的二进制表示中至少就有一位为1 。
     * <p>
     * 我们在结果数字中找到第一个为1 的位的位置，记为第N 位。现在我们以第N 位是不是1 为标准把原数组中的数字分成两个子数组，
     * 第一个子数组中每个数字的第N 位都为1 ，而第二个子数组的每个数字的第N 位都为0 。
     * <p>
     * 现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其它数字都出现了两次。
     * 因此到此为止，所有的问题我们都已经解决。
     */
    public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) {

        if (array == null || array.length <= 1) {
            num1[0] = 0;
            num2[0] = 0;
            return;
        }

        //异或运算结果
        int xorResult = 0;
        for (int i = 0; i < array.length; i++) {
            xorResult = xorResult ^ array[i];
        }


        /**
         * int 4字节 32bit 最高位为正负数代表 计算二进制结果xorResult从左到右的顺序 第一个位置为1的位置
         * 从左开始找到这个异或结果第一个为1的索引
         */
        int index = 0;
        while ((xorResult & 1) == 0 && index < 32) {
            xorResult = xorResult >> 1;
            index++;
        }

        //以这个索引处是否为1作为判定标准，就将两个不同的数分离开了
        //下面就是分两批不停地疑惑，就会得到这两个不同的数
        for (int j = 0; j < array.length; j++) {
            //这样就可以分别找到index处为1的独特解以及为0的独特解
            if (targetIndexIs1(array[j], index)) {
                num1[0] ^= array[j];
            } else {
                num2[0] ^= array[j];
            }
        }
    }

    /**
     * 判断num的index（从左往右看）是否为1
     */
    public boolean targetIndexIs1(int target, int index) {

        target = target >> index;
        if ((target & 1) == 1) {
            return true;
        } else {
            return false;
        }
    }

}
